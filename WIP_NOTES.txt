WIP Notes - RomWBW Emulator
===========================
Date: 2025-12-21

COMPLETED
---------
- D command (device list) now works at boot menu
- Assembly offset issues fixed by using explicit org directives instead of ds padding
- EMU_BNKCALL_PORT (0xED) added for HB_BNKCALL proxy calls at 0xFFF9
- CP/M 2.2 boots successfully
- Device enumeration shows MD0 (RAM), MD1 (ROM), HD0 (Hard Disk)
- CP/M 3 "failed to open CPM3.SYS" bug FIXED (see below)
- CP/M 3 banked mode now boots successfully! (see FIX: CP/M 3 CBIOS Loading below)
- MP/M 2 / ZPM3 boots successfully! (same fix as CP/M 3)

OUTSTANDING ISSUES
------------------
1. Disk Format Warning
   - hd1k_cpm3.img shows warning: "disk has FAT16/FAT32 MBR but no RomWBW partition"
   - Single-slice 8MB images may not be detected correctly
   - Combo disks with proper MBR work better

DEBUGGING NOTES FOR BANKED OS ISSUES (CP/M 3, MP/M 2, etc.)
-----------------------------------------------------------
If a banked OS loads but crashes/returns to boot menu, check these:

1. **Memory Protection Blocking DMA**
   Check romwbw_mem.h write_bank() for any protection ranges that might
   block disk DMA from writing to the correct addresses. The DEVMAP
   protection at 0x78678-0x7867B was blocking CP/M 3 CBIOS loading.

2. **xbnkmov Function Corruption**
   The xbnkmov routine (in CBIOS move.z80) handles interbank memory copies.
   If it's corrupted, all bank-to-bank copies fail. Key addresses:
   - xbnkmov starts around 0xFBE9 in common RAM
   - It should call BNKCPY at 0xFFF6 (port 0xEC)
   - Check that port 0xEC gets triggered during boot (should see 3+ calls)

3. **Debugging Techniques Used**
   a) Trace writes to specific addresses in store_mem():
      if (addr == 0xXXXX) fprintf(stderr, "[0x%04X] <- 0x%02X\n", addr, byte);

   b) Trace LDIR operations in execute loop:
      if (pc == 0xXXXX && opcode == 0xED) {
        fprintf(stderr, "LDIR: HL=0x%04X DE=0x%04X BC=0x%04X\n", ...);
      }

   c) Compare file bytes vs memory bytes:
      - Extract file: cpmcp -f wbw_hd1k disk.img 0:file.sys /tmp/file.sys
      - Hexdump file: xxd -s OFFSET -l 16 /tmp/file.sys
      - Hexdump ROM: xxd -s $((BANK*32768 + OFFSET)) -l 16 roms/emu_avw.rom

   d) Check I/O port stats at end of run:
      - Port 0xEC (BNKCPY) should be called 3+ times for CP/M 3
      - Port 0x78 (bank select) should be called many times

4. **Key Memory Locations**
   - 0xFFE0: CURBNK (current bank ID)
   - 0xFFE4: SRCBNK (source bank for BNKCPY)
   - 0xFFE7: DSTBNK (dest bank for BNKCPY)
   - 0xFFF0: HBIOS invoke
   - 0xFFF3: Bank select
   - 0xFFF6: BNKCPY trigger
   - 0xFFF9: BNKCALL trigger

5. **Common Symptoms**
   - OS prints signon then returns to boot menu = interbank copy failing
   - Stack corruption with return to 0x0200 = xbnkmov returning early
   - "60K TPA" prints but no prompt = CBIOS init$1 loop hanging

6. **File Locations in CPM3.SYS**
   The move.z80 code (xbnkmov) is at file offset ~0x0350-0x0380:
   - 0x0354: ED 43 xx xx = LD (srcbnk), BC (?xmove entry)
   - 0x0369: AF = XOR A (xbnkmov entry)
   - 0x0376: 3A 13 FC = LD A, (dstbnk) - the byte at 0x0378 should be 0xFC

FIX: CP/M 3 "failed to open CPM3.SYS"
-------------------------------------
Root cause: SYSSET BOOTINFO was parsing parameters incorrectly.

The RomWBW API for SYSSET BOOTINFO (0xF9E0) uses:
  D = unit, E = slice, L = bank (always 0)

But the emulator was reading the slice from L instead of E:
  - WRONG:  saved_boot_slice = cpu->regs.HL.get_low()
  - CORRECT: saved_boot_slice = cpu->regs.DE.get_low()

When CPMLDR calls SYSGET BOOTINFO (0xF8E0), it expects:
  D = unit, E = slice

With the bug, CPMLDR was getting slice=1 (from L) instead of slice=3 (from E)
when booting from slice 3, so it looked for CPM3.SYS on the wrong slice.

Fix in romwbw_emu.cc at SYSSET_BOOTINFO handler.

FIX: CP/M 3 CBIOS Loading (xbnkmov corruption)
----------------------------------------------
Root cause: A broken workaround in write_bank() was blocking disk DMA writes
to physical address 0x78678-0x7867B (common RAM at 0x8678-0x867B).

The DEVMAP protection workaround was intended to prevent HCB copy from
overwriting CBIOS data, but it was actually preventing the CPM3.SYS CBIOS
code from being written to the correct memory location.

When CPMLDR loaded CPM3.SYS via disk DMA, the CBIOS resident portion
(specifically the xbnkmov function) was blocked from being written.
Instead, old ROM loader code remained at 0x8600-0x8680. When this was
later copied to 0xFB80-0xFC00 (final CBIOS location), the wrong code
ended up in the xbnkmov function:

  Wrong:    LD A, (0x8813); POP AF; RET  (from romldr)
  Correct:  LD A, (0xFC13); CALL ?bnkxlt; LD (0xFFE7), A

This caused xbnkmov to return early without calling BNKCPY (0xFFF6),
breaking all interbank memory copies. The init$1 loop that clones
page zero between banks would fail, corrupting the stack and causing
the system to crash back to the boot menu.

Fix: Removed the DEVMAP protection workaround in romwbw_mem.h write_bank().

RECENT COMMITS
--------------
3b04dae Fix D command (device list) and assembly offset issues
459dcbb work on cpm3
34490ea Fix SYSGET_BOOTINFO to return actual boot unit and slice

KEY FILES
---------
- src/emu_hbios.asm - HBIOS proxy assembly (uses explicit org directives now)
- src/romwbw_emu.cc - Main emulator with HBIOS handlers
- roms/emu_avw.rom - Built ROM image for emulator
- roms/build_emu_rom.sh - Script to build ROM from HBIOS + RomWBW source

BUILD COMMANDS
--------------
cd roms
um80 -g ../src/emu_hbios.asm
ul80 -o emu_hbios.bin -p 0000 ../src/emu_hbios.rel
dd if=/dev/zero bs=32768 count=1 of=emu_hbios_32k.bin
dd if=emu_hbios.bin of=emu_hbios_32k.bin conv=notrunc
./build_emu_rom.sh SBC_simh_std.rom
cp emu_romwbw.rom emu_avw.rom

TEST COMMANDS
-------------
# Test D command:
(sleep 2; echo "D"; sleep 2) | timeout 8 ./src/romwbw_emu --romwbw=roms/emu_avw.rom --disk0=disks/hd1k_combo_v351.img

# Test CP/M 2.2 boot:
(sleep 2; echo "2.0"; sleep 3; echo "dir") | timeout 12 ./src/romwbw_emu --romwbw=roms/emu_avw.rom --disk0=disks/hd1k_combo_v351.img

# Test CP/M 3 boot:
(sleep 2; echo "2.3"; sleep 8; echo "dir"; sleep 3) | timeout 20 ./src/romwbw_emu --romwbw=roms/emu_avw.rom --disk0=disks/hd1k_combo_v351.img

# Test MP/M 2 / ZPM3 boot:
(sleep 2; echo "2.4"; sleep 15) | timeout 25 ./src/romwbw_emu --romwbw=roms/emu_avw.rom --disk0=disks/hd1k_combo_v351.img

NOTES ON ASSEMBLY OFFSET FIX
----------------------------
The ul80 linker has issues with ds padding when combined with multiple org
directives. The ds directive calculates padding based on current $, but the
linker doesn't handle this correctly when there are org gaps.

Solution: Use explicit org directives for all fixed addresses:
  - org 0008h for RST08
  - org 0010h for RST10
  - org 0120h for CB_HEAP
  - org 01D8h for bank IDs
  - org 0200h for HB_START
  - org 06E0h for PMGMT
  - org 06F0h for entry points

Note: The um80 project has fixed the ds/org issues.
